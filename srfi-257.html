<!DOCTYPE html>
<html lang="en">
<!--
SPDX-FileCopyrightText: 2024-2025 Sergei Egorov
SPDX-License-Identifier: MIT
-->
  <head>
    <meta charset="utf-8">
    <title>SRFI 257: Simple extendable pattern matcher with backtracking</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
     small { font-size: 14px; vertical-align: 2px; }
     body  { line-height: 24px; }
     pre  { font-family: inherit; line-height: 20px; }
    </style>
  </head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>257: Simple extendable pattern matcher with backtracking</h1>

<p>by Sergei Egorov</p>

<h2 id="status">Status</h2>

    <p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+257+at+srfi+dotschemers+dot+org">srfi-257@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-257/">archive</a>.</p>
    <ul>
      <li>Received: 2024-12-27</li>
      <li>60-day deadline: 2024-02-27</li>
      <li>Draft #1 published: 2024-12-29</li>
      <li>Draft #2 published: 2025-04-18</li>
      <li>Draft #3 published: 2025-09-01</li>
    </ul>

<h2 id="toc">Table of contents</h2>
<ul>
  <li><a href="#rationale">Rationale</a></li>
  <li>
    <a href="#examples">Examples</a>
    <ul>
      <li><a href="#srfi-204-examples">SRFI-204 Examples</a></li>
      <li>
        <a href="#advanced-examples">Advanced Examples</a>
        <ul>
          <li><a href="#backtracking">Backtracking</a></li>
          <li><a href="#custom-match-forms">Custom match forms</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href="#specification">Specification</a>
    <ul>
      <li><a href="#basic-patterns">Basic patterns</a></li>
      <li><a href="#value-pattern">The Value pattern</a></li>
      <li><a href="#list-patterns">List patterns</a></li>
      <li><a href="#vector-patterns">Vector patterns</a></li>
      <li><a href="#string-patterns">String patterns</a></li>
      <li><a href="#conversion-patterns">Conversion patterns</a></li>
      <li><a href="#predicate-patterns">Predicate patterns</a></li>
      <li><a href="#logical-patterns">Logical patterns</a></li>
      <li><a href="#compatibility-patterns">Compatibility patterns</a></li>
      <li><a href="#core-patterns">Core patterns</a></li>
      <li><a href="#pattern-language-construction-patterns">Pattern language construction patterns</a></li>
      <li><a href="#defining-new-patterns">Defining new patterns</a></li>
      <li><a href="#elements-of-templating">Elements of templating</a></li>
    </ul>
  </li>
  <li>
    <a href="#sublibs">Sublibraries and optional features</a>
    <ul>
      <li><a href="#sublibs-misc">The ‘misc’ sublibrary</a></li>
      <li><a href="#sublibs-box">The ‘box’ sublibrary</a></li>
      <li><a href="#sublibs-rx">The ‘rx’ sublibrary</a></li>
      <li><a href="#optional-features">Optional features</a></li>
    </ul>
  </li>
  <li>
    <a href="#appendix">Appendix</a>
    <ul>
      <li><a href="#derived-pattern-types">Derived pattern types</a></li>
    </ul>
  </li>
  <li><a href="#implementation">Implementation</a></li>
  <li><a href="#acknowledgements">Acknowledgements</a></li>
</ul>

<h2 id="abstract">Abstract</h2>

<p>
Pattern matching extends Scheme's repertoire of conditional constructs, allowing
decomposition of compound data structures and binding their parts to variables.
This SRFI proposes one such construct, <code>match</code>, which provides all
common-denominator functionality described in <a href="https://srfi.schemers.org/srfi-200/">SRFI-200</a>,
adding on top of it support for non-linear patterns and backtracking. Also, the
proposed construct is modular, and allows for convenient extension via the
<code>define-match-pattern</code> mechanism.
</p>

<h2 id="issues">Issues</h2>

<p>Currently, none.</p>

<h2 id="rationale">Rationale</h2>

<p>
This SRFI proposes a construct with functionality similar to the one of “Wright-style”
pattern matcher (see <a href="https://srfi.schemers.org/srfi-204/">SRFI-204</a>), with the following
differences: it supports backtracking, and it is designed in a modular way, allowing user extensions
not only in the form of new types of patterns, but also new pattern matching languages, such as
the Dybvig-Friedman-Hilsdale matcher (<a href="https://srfi.schemers.org/srfi-241/">SRFI-241</a>).
</p>

<p>
This proposal is influenced by the design of the Gerbil matcher
(<a href="https://gerbil.scheme.org/reference/gerbil/prelude/macros.html#pattern_matching">see here</a>).
It features patterns resembling corresponding constructors, e.g. <code>(vector (cons x y))</code>,
unlike most other designs, where patterns resemble printed representation of data, e.g. <code>#((x . y))</code>,
or mix both forms to support pattern combinators such as <code>and</code>. However, while in most other designs
the set of constructor-like pattern forms is fixed, and their names are hardwired in the design,
the proposed construct makes  constructor-like pattern forms “first-class” components that
can be created/imported/exported independently; they are just macros, implementing an
internal protocol.
</p>

<p>
The downside of this approach is that one can no longer name pattern matchers after regular
constructors as they cannot share the same namespace. To stay within the bounds of what can be
implemented via regular <code>syntax-rules</code>, the choice was made to use tilde-prefixed names,
so the above pattern becomes <code>(~vector (~cons x y))</code>. This convention is used for all
forms of patterns except for <code>quote</code> and <code>quasiquote</code>, which have convenient
reader abbreviations and thus are built into the matcher.
</p>

<p>
Traditional patterns, resembling printed representations, are supported “under quasiquote”,
as proposed in (withdrawn) <a href="https://srfi.schemers.org/srfi-200/">SRFI-200</a>.
New types of patterns as well as new forms of pattern languages can be built via
<code>define-match-pattern</code> form, which provides a <code>syntax-rules</code> -like
mechanism for pattern rewriting.
</p>

<h2 id="examples">Examples</h2>

<h3 id="srfi-204-examples">SRFI-204 Examples</h3>

<p>
The examples below are taken from <a href="https://srfi.schemers.org/srfi-204/">SRFI-204</a>
and adapted to demonstrate the same functionality using the proposed pattern syntax in its
constructor-like and quasiquoted forms:
</p>

<p> Literal patterns: </p> <pre><code>(<b>let</b> ([ls (list 'a "b" #f 2 '() #\c '#(1))])
  (list (<b>match</b> ls [(~list 'a "b" #f 2 '() #\c #(1)) 'ok])
        (<b>match</b> ls [`(a "b" #f 2 () #\c #(1)) 'ok])))
⟹ (ok ok)

</code></pre> <p> Pattern variables: </p> <pre><code>(<b>match</b> (list 1 2 3) [(~list a b c) b]) ⟹ 2
(<b>match</b> (list 1 2 3) [(~list _ b _) b]) ⟹ 2
(<b>match</b> (list 1 2 3) [`(a ,b c) b] [_ 'fail]) ⟹ fail
(<b>match</b> (list 1 2 3) [`(1 ,b ,_) b] [_ 'fail]) ⟹ 2

</code></pre> <p> Nonlinear patterns: </p> <pre><code>(<b>match</b> (list 'A 'B 'A) [(~list a b a) a] [_ 'fail]) ⟹ A
(<b>match</b> (list 'A 'B 'A) [`(,a b ,a) a] [_ 'fail]) ⟹ fail
(<b>match</b> (list 'A 'B 'A) [`(,a B ,a) a] [_ 'fail]) ⟹ A
(<b>match</b> (list 'A 'B 'A) [`(,a ,b ,a) a] [_ 'fail]) ⟹ A

</code></pre> <p> In this proposal, quasiquoted and regular patterns can be arbitrarily combined: </p>
<pre><code>(<b>let</b> ([x '(1 2 3 4)])
  (list (<b>match</b> x [(~cons a (~append b (~list c))) (list a b c)])
        (<b>match</b> x [(~cons a `(,@b ,@(~list c))) (list a b c)])
        (<b>match</b> x [(~cons a `(,@b ,c)) (list a b c)])
        (<b>match</b> x [`(,a ,@b ,c) (list a b c)])))
⟹ ((1 (2 3) 4) (1 (2 3) 4) (1 (2 3) 4) (1 (2 3) 4))

</code></pre> <p> Ellipsis (<code>~etc</code>) and tail patterns: </p> <pre><code>(<b>match</b> (list 1 2) [(~list* 1 2 (~etc 3)) #t]) ⟹ #t
(<b>match</b> (list 1 2 3) [(~list* 1 2 (~etc 3)) #t]) ⟹ #t
(<b>match</b> (list 1 2 3 3 3) [(~list* 1 2 (~etc 3)) #t]) ⟹ #t

(<b>match</b> '((a time) (stitch saves) (in nine)) [(~etc (~list x y)) (list x y)])
⟹ ((a stitch in) (time saves nine))

(<b>match</b> '((a b) (c d) (e f)) [(~etc (~list x y)) (list x y)])
⟹ ((a c e) (b d f))

(<b>define</b> (transpose x)
  (<b>match</b> x [(~etc (~cons a (~etc b))) (cons a (transpose b))] [_ '()]))

(transpose '((1 2 3) (4 5 6))) ⟹ ((1 4) (2 5) (3 6))

(<b>define</b> (palindrome? str)
  (<b>let</b> loop ([chars (filter char-alphabetic?
                            (string-&gt;list (string-foldcase str)))])
    (<b>match</b> chars
      ['() #t]
      [(~list a) #t]
      [(~cons a (~append (~etc b) (~list a))) (loop b)]
      [_ #f])))

(palindrome? "Able was I, ere I saw Elba.") ⟹ #t
(palindrome? "Napoleon") ⟹ #f

(<b>define</b> (first-column x)
  (<b>match</b> x [(~etc (~cons a (~etc _))) a]))

(first-column '((1 2 3) (4 5 6) (7 8 9))) ⟹ (1 4 7)

</code></pre> <p> This proposal disagrees with “Wright-style” matcher (WSM) on <code>quasiquote</code> <code>unquote-splicing</code> patterns; in this proposal, they are
treated in accordance with the regular quasiquote rules, rather than being turned into <code>...</code> repeats: </p> <pre><code>(<b>match</b> (list 1 2) [`(1 2 ,@3) #t] [_ #f]) ⟹ #f ;</code> WSM returns <code>#t
(<b>match</b> '(1 2 . 3) [`(1 2 ,@3) #t] [_ #f]) ⟹ #t ;</code> WSM returns <code>#f
(<b>match</b> (list 1 2 3 3 3) [`(1 2 ,@3) #t] [_ #f]) ⟹ #f ;</code> WSM returns <code>#t

</code></pre> <p> WSM-compatible behavior can be imitated by explicit insertion of <code>~etc</code>:  </p>
<pre><code>(<b>match</b> (list 1 2) [`(1 2 ,@(~etc 3)) #t] [_ #f]) ⟹ #t
(<b>match</b> '(1 2 . 3) [`(1 2 ,@(~etc 3)) #t] [_ #f]) ⟹ #f
(<b>match</b> (list 1 2 3 3 3) [`(1 2 ,@(~etc 3)) #t] [_ #f]) ⟹ #t

</code></pre> <p> Unlike WSM, this proposal supports non-linearity in and out of “ellipsis” patterns: </p>
<pre><code>(<b>match</b> '((1 2 3 4) ((1) (2) (3) (4)) (1 2 3 4))
  [(~list a* (~etc (~list a*)) a*) a*])
⟹ (1 2 3 4)

</code></pre>
<p>Some WSM postfix operators do not have built-in equivalents, but can be easily defined.
An analog of WSM <code>**1</code> can be defined as follows: </p> <pre><code>(<b>define-match-pattern</b> ~etc+ ()
  [(~etc+ p) (~pair? (~etc p))])

(<b>match</b> (list 1 2) [(~list* a b (~etc+ c)) c] [_ #f]) ⟹ #f
(<b>match</b> (list 1 2 3) [(~list* a b (~etc+ c)) c] [_ #f]) ⟹ (3)

</code></pre> <p> An analog of WSM <code>=..</code> <i>k</i> can be defined as follows: </p> <pre><code>(<b>define-match-pattern</b> ~etc= ()
  [(~etc= k p)
   (~and (~list? (~prop length =&gt; k))
         (~etc p))])

(<b>match</b> '((a b) (c d) (e f))
  [(~etc= 3 (~list x y)) (list x y)]
  [_ 'fail])
⟹ ((a c e) (b d f))

(<b>match</b> '((a b) (c d) (e f) (g h))
  [(~etc= 3 (~list x y)) (list x y)]
  [_ 'fail])
⟹ fail

</code></pre> <p> An analog of WSM <code>*..</code> <i>k</i> <i>j</i> can be defined as follows: </p> <pre><code>(<b>define-match-pattern</b> ~etc** ()
  [(~etc** k j p)
   (~and (~list? (~prop length =&gt; (~and (~test &gt;= (k)) (~test &lt;= (j)))))
         (~etc p))])

(<b>match</b> '((a b) (c d) (e f))
  [(~etc** 2 4 (~list x y)) (list x y)]
  [_ 'fail])
⟹ ((a c e) (b d f))

(<b>match</b> '((a b) (c d) (e f) (g h))
  [(~etc** 2 4 (~list x y)) (list x y)]
  [_ 'fail])
⟹ ((a c e g) (b d f h))

(<b>match</b> '((a b) (c d) (e f) (g h) (i j))
  [(~etc** 2 4 (~list x y)) (list x y)]
  [_ 'fail])
⟹ fail

</code></pre> <p> Tail patterns will match dotted pairs, and ellipsis patterns won't: </p> <pre><code>(<b>define</b> (keys x)
  (<b>match</b> x [(~etc (~cons a (~etc _))) a] [_ 'fail]))

(keys '((a 1) (b 2) (c 3))) ⟹ (a b c)
(keys '((a . 1) (b . 2) (c . 3))) ⟹ fail

(<b>define</b> (keys x)
  (<b>match</b> x [(~etc (~cons a _)) a] [_ 'fail]))

(keys '((a 1) (b 2) (c 3))) ⟹ (a b c)
(keys '((a . 1) (b . 2) (c . 3))) ⟹ (a b c)

</code></pre> <p> Logical patterns: </p> <pre><code>(<b>match</b> 1 [(~and) #t]) ⟹ #t
(<b>match</b> 1 [(~and x) x]) ⟹ 1
(<b>match</b> 1 [(~and x 1) x]) ⟹ 1

(<b>match</b> #f [(~and) #t] [_ #f]) ⟹ #t
(<b>match</b> #f [(~and x) (=&gt; fail) (<b>if</b> x #t (fail))] [_ #f]) ⟹ #f

(<b>match</b> 1 [(~or) #t] [_ #f]) ⟹ #f
(<b>match</b> 1 [(~or x) x]) ⟹ 1
(<b>match</b> 1 [(~or x 2) x]) ⟹ 1

(<b>define</b> (last-matches-one-of-first-three x)
  (<b>match</b> x [`(,a ,a) #t]
           [`(,a ,b ,@c ,(~or a b)) #t]
           [`(,a ,b ,c ,@d ,c) #t]
           [_ #f]))

(last-matches-one-of-first-three '(1 2 3 4 5 1)) ⟹ #t
(last-matches-one-of-first-three '(1 2 3 4 5 2)) ⟹ #t
(last-matches-one-of-first-three '(1 2 3 4 5 3)) ⟹ #t
(last-matches-one-of-first-three '(1 2 3 4 5 6)) ⟹ #f

(<b>define</b> (last-matches-one-of-first-three2 x)
  (<b>match</b> x
    [`(,a ,a) #t]
    [`(,a ,b ,@c ,d) (=&gt; fail)
     (<b>if</b> (or (equal? d a) (equal? d b)) #t (fail))]
    [`(,a ,b ,c ,@d ,e) (equal? c e)]
    [_ #f]))

(last-matches-one-of-first-three2 '(1 2 3 4 5 1)) ⟹ #t
(last-matches-one-of-first-three2 '(1 2 3 4 5 2)) ⟹ #t
(last-matches-one-of-first-three2 '(1 2 3 4 5 3)) ⟹ #t
(last-matches-one-of-first-three2 '(1 2 3 4 5 6)) ⟹ #f

</code></pre> <p> This proposal explicitly assigns <code>#f</code> to undefined <code>~or</code> variables: </p> <pre><code>(<b>match</b> '(0 1 2 3 4 5 6 7)
  [(~etc (~or 2 6 rest)) rest])
⟹ (0 1 #f 3 4 5 #f 7)

</code></pre> <p>Single-argument <code>~not</code> patterns are supported.
It is an error for a pattern to refer to the same variable inside and outside of a <code>~not</code> pattern. </p> <pre><code>(<b>match</b> 1 [(~and x (~not #f)) x] [_ 'fail]) ⟹ 1
(<b>match</b> #f [(~and x (~not #f)) x] [_ 'fail]) ⟹ fail
(<b>match</b> 1 [(~not 2) #t]) ⟹ #t

</code></pre> <p> Predicates and fields are supported via <code>~?</code> and <code>~=</code>
respectively.
It is an error to refer to pattern variables in non-subpattern parts of these patterns.
</p>

<pre><code>(<b>match</b> 1 [(~? odd? x) x]) ⟹ 1
(<b>match</b> '(a) [(~= car x) x]) ⟹ a

</code></pre> <p>Tests that use more than one pattern variable should be implemented
in the body of the corresponding rule:
</p>

<pre><code>(<b>define</b> (fibby? x)
  (<b>match</b> x
    [(~list* a b c rest)
     (<b>if</b> (= (+ a b) c) (fibby? (cons b (cons c rest))) #f)]
    [(~list a b) #t]
    [(~list a) #t]
    ['() #t]
    [_ #f]))

(fibby? '(4 7 11 18 29 47)) ⟹ #t

</code></pre>

<h3 id="advanced-examples">Advanced Examples</h3>

<p>
This section contains examples specific to new functionality proposed in this SRFI.
</p>

<h4 id="backtracking">Backtracking</h4>

<p>
Some patterns marked as “iterative” in this proposal may match the input object
in multiple ways, or “solutions”, backtracking to the next solution if the current
one causes downstream patterns to fail (structurally or because of a disagreement
in values of shared pattern variables). This process may be time-consuming, but
is associated only with iterative patterns, causing no overhead if they are not
used.</p>

<p>
Iteration strategies vary between pattern types.
Regular versions of append matchers are greedy, giving preference
to long leftmost segments:
</p>

<pre><code>(<b>define</b> (pr* p . x*)
  (for-each (<b>lambda</b> (x) (display x p)) x*))

(<b>let</b> ([p (open-output-string)])
  (<b>match</b> "abc"
    [(~string-append a (~string b) c)
     (=&gt; next) (pr* p "1:" a "+" b "+" c ";") (next)]
    [(~string-append a c)
     (=&gt; next) (pr* p "2:" a "+" c ";") (next)]
    [x (get-output-string p)]))
⟹ "1:ab+c+;2:abc+;"
</code></pre>

<p> Non-greedy appends give preference to short leftmost segments: </p>

<pre><code>(<b>let</b> ([p (open-output-string)])
  (<b>match</b> "abc"
    [(~string-append/ng a (~string b) c)
     (=&gt; next) (pr* p "1:" a "+" b "+" c ";") (next)]
    [(~string-append/ng a c)
     (=&gt; next) (pr* p "2:" a "+" c ";") (next)]
    [x (get-output-string p)]))
⟹ "1:+a+bc;2:+abc;"
</code></pre>

<p> Backtracking can be triggered explicitly from the body; calling “back”
guard formal retries starting from the current pattern's most recent backtracking
point or next rule if none left: </p>

<pre><code>(<b>let</b> ([p (open-output-string)])
  (<b>match</b> "abc"
    [(~string-append a (~string b) c)
     (=&gt; next back) (pr* p "1:" a "+" b "+" c ";") (back)]
    [(~string-append a c)
     (=&gt; next back) (pr* p "2:" a "+" c ";") (back)]
    [x (get-output-string p)]))
⟹ "1:ab+c+;1:a+b+c;1:+a+bc;2:abc+;2:ab+c;2:a+bc;2:+abc;"
</code></pre>

<h4 id="custom-match-forms">Custom match forms</h4>

<p>
It is relatively easy to define custom match forms with a different pattern grammar
using a combination of “converter” patterns defined via <code>define-match-pattern</code>
and regular <code>syntax-rule</code> -based macro for the form itself. This process is
facilitated by a collection of special-purpose patterns, as shown below.
</p>

<p>
Defining an analog of Dybvig-Friedman-Hilsdale matcher with support for catamorphism feature:
</p>

<pre><code>(<b>define-match-pattern</b> ~cmp-&gt;p (&lt;...&gt; &lt;_&gt; unquote -&gt;)
  [(_ l ,(x)) (~prop l =&gt; x)]
  [(_ l ,(f -&gt; x ...)) (~prop f =&gt; x ...)]
  [(_ l ,(x ...)) (~prop l =&gt; x ...)]
  [(_ l ,&lt;_&gt;) _]
  [(_ l ,x) x]
  [(_ l ()) '()]
  [(_ l (x &lt;...&gt;)) (~etc (~cmp-&gt;p l x))] ; optimization
  [(_ l (x &lt;...&gt; . y)) (~append/t y (~etc (~cmp-&gt;p l x)) (~cmp-&gt;p l y))]
  [(_ l (x . y)) (~cons (~cmp-&gt;p l x) (~cmp-&gt;p l y))]
  [(_ l #(x ...)) (~list-&gt;vector (~cmp-&gt;p l (x ...)))]
  [(_ l other) 'other])

(<b>define-syntax</b> cm-match
  (<b>syntax-rules</b> (guard)
    [(_ () l x () (c ...))
     (<b>match</b> x c ... [_ (error "cm-match error" x)])]
    [(_ () l x ([cmp (guard . e*) . b] cmc ...) (c ...))
     (<b>cm-match</b> () l x (cmc ...)
       (c ... [(~replace-specials &lt;...&gt; &lt;_&gt; (~cmp-&gt;p l cmp))
                 (=&gt; n) (<b>if</b> (<b>and</b> . e*) (<b>let</b> () . b) (n))]))]
    [(_ () l x ([cmp . b] cmc ...) (c ...))
     (<b>cm-match</b> () l x (cmc ...)
       (c ... [(~replace-specials &lt;...&gt; &lt;_&gt; (~cmp-&gt;p l cmp))
                 (<b>let</b> () . b)]))]
    [(_ x cmc ...)
     (<b>let</b> l ([v x]) (<b>cm-match</b> () l v (cmc ...) ()))]))
</code></pre>

<p>
Note the use of <code>~replace-specials</code> pattern that substitutes
<code>&lt;...&gt; &lt;_&gt;</code> for special <code>... _</code> identifiers
to allow them to have their regular meaning inside <code>define-match-pattern</code>.
It also uses the <code>~append/t</code> pattern, a non-iterative list append
that takes the length of the tail segment from its first argument.
</p>
<p>
Defined in this manner, <code>cm-match</code> can be used as D-F-H <code>match</code>
w.r.t. matching functionality (no enhanced right-hand-side <code>quasiquote</code>):
</p>

<pre><code>(<b>let</b> ([simple-eval
       (<b>lambda</b> (x)
         (<b>cm-match</b> x
           [,i (guard (integer? i)) i]
           [(+ ,[x*] ...) (apply + x*)]
           [(* ,[x*] ...) (apply * x*)]
           [(- ,[x] ,[y]) (- x y)]
           [(/ ,[x] ,[y]) (/ x y)]
           [,x (error "invalid expression" x)]))])
    (simple-eval '(+ (- 0 1) (+ 2 3))))
⟹
4

(<b>let</b> ([split
       (<b>lambda</b> (lis)
        (<b>cm-match</b> lis
          [() (values '() '())]
          [(,x) (values `(,x) '())]
          [(,x ,y . ,[odds evens])
           (values `(,x . ,odds)
                   `(,y . ,evens))]))])
  (split '(a b c d e f)))
⟹
(a c e)
(b d f)

</code></pre> <p> Defining a <code>syntax-rules</code> -like matcher with explicit list of literal identifiers: </p>

<pre><code>(<b>define-match-pattern</b> ~srp-&gt;p (&lt;...&gt; &lt;_&gt;)
  [(_ l* ()) '()]
  [(_ l* (x &lt;...&gt;)) (~etc (~srp-&gt;p l* x))] ; optimization
  [(_ l* (x &lt;...&gt; . y)) (~append/t y (~etc (~srp-&gt;p l* x)) (~srp-&gt;p l* y))]
  [(_ l* (x . y)) (~cons (~srp-&gt;p l* x) (~srp-&gt;p l* y))]
  [(_ l* #(x ...)) (~list-&gt;vector (~srp-&gt;p l* (x ...)))]
  [(_ l* &lt;_&gt;) _]
  [(_ l* a) (~if-id-member a l* 'a a)])

(<b>define-syntax</b> sr-match
  (<b>syntax-rules</b> (=&gt;)
    [(_ () l* v () (c ...))
     (<b>match</b> v c ... [_ (error "sr-match error" v)])]
    [(_ () l* v ([srp . b] src ...) (c ...))
     (sr-match () l* v (src ...) (c ...
       [(~replace-specials &lt;...&gt; &lt;_&gt; (~srp-&gt;p l* srp)) . b]))]
    [(_ x (l ...) src ...)
     (<b>let</b> ([v x]) (sr-match () (l ...) v (src ...) ()))]))
</code></pre>
  <p> Note the use of <code>~if-id-member</code> pattern to check if an atom is a literal.  </p>

<pre><code>(sr-match '(begin (a 5) (b 6) (c 7) (d 8))
  (begin)
  [(begin (x* y*) ...) (list x* y*)])
⟹ ((a b c d) (5 6 7 8))

(sr-match '((a b c d) (e f g) (h i) (j))
  ()
  [((x* y** ...) ...) (list x* y**)])
⟹ ((a e h j) ((b c d) (f g) (i) ()))

</code></pre>

<h2 id="specification">Specification</h2>

<p>
The grammar rules for the <code>match</code> form are:
</p>
<p>
&nbsp;&nbsp;&nbsp;⟨<i>match expression</i> ⟩ ⟶ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;<code>(match</code> ⟨<i>expression</i> ⟩ ⟨<i>match rule</i> ⟩*<code>)</code><br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>match rule</i> ⟩ ⟶<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;<code>(</code> ⟨<i>match pattern</i> ⟩ <code>(=&gt;</code> ⟨<i>next id</i> ⟩ ⟨<i>back id</i> ⟩<code>)</code> ⟨<i>body</i> ⟩ <code>)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>(</code> ⟨<i>match pattern</i> ⟩ <code>(=&gt;</code> ⟨<i>next id</i> ⟩<code>)</code> ⟨<i>body</i> ⟩ <code>)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>(</code> ⟨<i>match pattern</i> ⟩ ⟨<i>body</i> ⟩ <code>)</code><br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>match pattern</i> ⟩ ⟶ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;⟨<i>underscore</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>match pattern identifier</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>atomic datum</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>(quote</code> ⟨<i>datum</i> ⟩<code>)</code> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>(quasiquote</code> ⟨<i>match quasipattern</i> ⟩<code>)</code> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>(</code>⟨<i>match pattern name</i> ⟩ ⟨<i>match pattern argument</i> ⟩*<code>)</code> <br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>match quasipattern</i> ⟩ ⟶<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;<code>()</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>atomic datum</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>match quasipattern symbol</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>(unquote</code> ⟨<i>match pattern</i> ⟩<code>)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>((unquote-splicing</code> ⟨<i>match pattern</i> ⟩<code>)</code> <code>.</code> ⟨<i>match quasipattern</i> ⟩<code>)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>(</code>⟨<i>match quasipattern</i> ⟩ <code>.</code> ⟨<i>match quasipattern</i> ⟩<code>)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;<code>#(</code>⟨<i>match quasipattern</i> ⟩*<code>)</code><br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>atomic datum</i> ⟩ ⟶<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>boolean</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>number</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>character</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>string</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>bytevector</i> ⟩<br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>match pattern name</i> ⟩ ⟶<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;⟨<i>any identifier except </i> <code>quote</code><i> and </i> <code>quasiquote</code>⟩<br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>match pattern argument</i> ⟩ ⟶<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;⟨<i>match pattern</i> ⟩<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>|</code>&nbsp;&nbsp;&nbsp;⟨<i>expression</i> ⟩<br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>match pattern identifier</i> ⟩ ⟶ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;⟨<i>any identifier except </i> <code>_</code><i> and </i> <code>...</code>⟩<br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>next id</i> ⟩ ⟶ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;⟨<i>identifier</i> ⟩<br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>back id</i> ⟩ ⟶ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;⟨<i>identifier</i> ⟩<br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>match quasipattern symbol</i> ⟩ ⟶ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;⟨<i>any identifier except </i> <code>unquote</code><i> and </i> <code>unquote-splicing</code> ⟩<br>
<br>
&nbsp;&nbsp;&nbsp;⟨<i>underscore</i> ⟩ ⟶<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&nbsp;</code>&nbsp;&nbsp;&nbsp;⟨<i>the identifier _</i> ⟩<br>
<br>
</p>

<p>Note: <code>_</code>&thinsp;, <code>...</code>&thinsp;, <code>=&gt;</code>, <code>quote</code>, <code>quasiquote</code>,
<code>unquote</code>, and <code>unquote-splicing</code> in this specification are used as auxiliary syntaxes
identical to the like-named syntaxes exported by the standard libraries.
</p>

<p>
The <code>match</code> form behaves as follows. First, its ⟨<i>expression</i> ⟩
argument is evaluated. It should return a single value, which is subsequently tested against match
rules in the order they are written until a matching rule is found. If no matching rules are found,
<code>match</code> returns an undefined value.
</p>

<p>
A rule matches if the application of its pattern to the input object is successful and there is
no “guard clause” (a list of the <code>=&gt;</code> keyword followed by one or two identifiers). If a guard
clause is present, it binds the identifiers to procedures allowing advanced control over the matching
process. The first procedure, bound within the body to ⟨<i>next id</i> ⟩, allows
one to skip the current rule as if its pattern match was unsuccessful. In two-identifier guard clauses,
the second procedure, bound within the body to ⟨<i>back id</i> ⟩, allows one to
tell the matcher that the current pattern should consider another way to match, or, if no such way exists,
to skip the pattern as if its attempts to match were unsuccessful.
Both procedures accept no arguments and can be called from any <i>tail position</i> within the
body. If these procedures are called in a different way, the behavior is undefined.
</p>

<p>
Patterns may contain <i>pattern variables</i>, which, if the application of a pattern succeeds, become
bound in the corresponding body to parts of the input object. The values of these variables may be
used to reject the match via the guard clause mechanism described above.
</p>

<p>
Any pattern containing pattern variables may use the same variable in more than one place within the
pattern. In such cases all the corresponding sub-objects, assigned to the repeated variable,
should “agree”, i.e. to be the same according to the <code>equal?</code> predicate.
</p>

<p>
Some patterns, marked as <i>(iterative)</i>  in the pattern entry's header line, may match the input
object in multiple ways. The matcher tries these different matches in the order specified in the
pattern description. The two common orders are <i>(iterative, greedy)</i> , maximizing the number
of input elements matched by sub-patterns on the left, and <i>(iterative, non-greedy)</i> , maximizing
the number of input elements matched by sub-patterns on the right. When iterative patterns are
nested, the matcher acts as if the outer pattern has full control over the decomposition of the input object,
allowing its immediate sub-patterns to work with the parts in the order the outer pattern supplies them.
</p>

<h3 id="basic-patterns">Basic patterns</h3>

<p>
⟨<i>atomic datum</i> ⟩ &nbsp;&nbsp;<i>match pattern</i><br>
Literal patterns, ⟨<i>boolean</i> ⟩, …,
⟨<i>bytevector</i> ⟩, match equal objects (in terms of
Scheme <code>equal?</code> predicate).
</p>

<p>
<code><b>_</b></code> &nbsp;&nbsp;<i>match pattern</i><br>
The ⟨<i>underscore</i> ⟩ pattern matches anything. It is
not a variable, so it produces no bindings visible in the body of the rule.
</p>

<p>
⟨<i>match pattern identifier</i> ⟩ &nbsp;&nbsp;<i>match pattern</i><br>
The ⟨<i>match pattern identifier</i> ⟩ pattern acts like a
pattern variable. A pattern variable will match any value and can be repeated.
If repeated, all subsequent like-named variables will only match the value that
is <code>equal?</code> to the value matched by the first. This value is made
available inside ⟨<i>body</i> ⟩ as if a local identifier
with the same name is bound to this value via the <code>let</code> form surrounding
the body. It is an error to refer to pattern identifiers in expressions within
the same pattern, or to use them as ⟨<i>match pattern name</i> ⟩s.
</p>

<p>
<code>(<b>quote</b></code> ⟨<i>datum</i> ⟩<code>)</code>&nbsp;&nbsp;<i>match pattern</i><br>
The <code>quote</code> pattern matches ⟨<i>datum</i> ⟩.  Again, the Scheme <code>equal?</code>
predicate is used for comparison.
</p>

<p>
<code>(<b>quasiquote</b></code> ⟨<i>match quasipattern</i> ⟩<code>)</code>&nbsp;&nbsp;<i>match pattern</i><br>
The <code>quasiquote</code> pattern can be understood in terms of regular patterns. It is translated
into combinations of basic patterns and data patterns (see below). The translation
function T[⟨<i>match quasipattern</i> ⟩] ⟹ ⟨<i>match pattern</i> ⟩
resembles simplified translation of the regular <code>quasiquote</code> form (shown in
abbreviated form, first matching rule is chosen):
</p>
<table>
  <tbody><tr><td>T[<code>()</code>]</td> <td>&nbsp;⟹&nbsp;</td> <td><code>(quote ())</code></td></tr>
  <tr><td>T[⟨<i>atomic datum</i> ⟩]</td> <td>&nbsp;⟹&nbsp;</td> <td>⟨<i>atomic datum</i> ⟩</td></tr>
  <tr><td>T[<code>(unquote</code> ⟨<i>mp</i> ⟩<code>)</code>]</td>
    <td>&nbsp;⟹&nbsp;</td> <td>⟨<i>mp</i> ⟩</td></tr>
  <tr><td>T[<code>((unquote-splicing</code> ⟨<i>mp</i> ⟩<code>))</code>]</td>
    <td>&nbsp;⟹&nbsp;</td> <td>⟨<i>mp</i> ⟩</td></tr>
  <tr><td>T[<code>((unquote-splicing</code> ⟨<i>mp</i> ⟩<code>)</code> <code>.</code>
     ⟨<i>mqp</i> ⟩<code>)</code>]</td>
    <td>&nbsp;⟹&nbsp;</td> <td><code>(<b>~append</b></code> ⟨<i>mp</i> ⟩
       T[⟨<i>mqp</i> ⟩]<code>)</code></td></tr>
  <tr><td>T[<code>(</code>⟨<i>mqp</i> <sub>1</sub>⟩ <code>.</code>
    ⟨<i>mqp</i> <sub>2</sub>⟩<code>)]</code></td>
    <td>&nbsp;⟹&nbsp;</td> <td><code>(<b>~cons</b></code> T[⟨<i>mqp</i> <sub>1</sub>⟩]
       T[⟨<i>mqp</i> <sub>2</sub>⟩]<code>)</code></td></tr>
  <tr><td>T[<code>#(</code>⟨<i>mqp</i> ⟩*)]</td>
    <td>&nbsp;⟹&nbsp;</td> <td><code>(<b>~vector</b></code>
      T[⟨<i>mqp</i> <sub>1</sub>⟩]*<code>)</code></td></tr>
</tbody></table>

<h3 id="value-pattern">The Value pattern</h3>

<p>
  <code>(<b>~value</b></code> ⟨<i>expression</i> ⟩<code>)</code>&nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~value</code> pattern matches if the input object is equal to the result of
  ⟨<i>expression</i> ⟩, calculated during the match.  The Scheme <code>equal?</code>
  predicate is used for comparison. This is a convenient way to match against non-pattern variables
  bound outside the <code>match</code> form.
</p>


<h3 id="list-patterns">List patterns</h3>

<p>List patterns match various types of pairs/lists, disassembling them into sub-expressions
and applying to them sub-patterns. They are named to resemble the corresponding Scheme constructors,
and can be combined in a similar manner. Their names are not built into the matcher, but
are defined via <code>define-syntax</code> or its equivalent, so they need to be imported
if used explicitly.
</p>

<p>
<code>(<b>~cons</b></code> ⟨<i>mp</i> <sub>a</sub>⟩ ⟨<i>mp</i> <sub>d</sub>⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
The <code>~cons</code> pattern matches a pair whose <i>car</i>  matches
⟨<i>mp</i> <sub>a</sub>⟩ and whose <i>cdr</i>  matches
⟨<i>mp</i> <sub>d</sub>⟩.
</p>

<p>
  <code>(<b>~list</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~list</code> pattern matches a proper list, with as many elements
  as there are sub-patterns ⟨<i>mp</i> ⟩ … The elements
  should match the corresponding patterns.
</p>

<p>
  <code>(<b>~append</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern (iterative, greedy)</i><br>
  The <code>~append</code> pattern matches a (possibly improper) list, breaking it into
  sub-list segments that can match the corresponding patterns
  ⟨<i>mp</i> ⟩ … If the list is improper, the last
  pattern is applied to its improper tail segment.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  This is an example of a <i>iterative</i>
  pattern that may match the target list in many different ways; all “solutions” are equally good,
  as long as the segments can be appended via <code>append</code> to make a list equal to the original.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;The solutions are tried starting with ones maximizing the length of the leftmost
  segment, then the segment after it, etc.
</p>

<p>
  <code>(<b>~append/ng</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern (iterative, non-greedy)</i><br>
  The <code>~append/ng</code> pattern is a “non-greedy” variant of the
  <code>~append</code> pattern. The solutions are tried starting with the ones maximizing
  the length of the rightmost segment, then the segment before it, etc.
</p>

<p>
  <code>(<b>~append/t</b></code> ⟨<i>datum</i> ⟩ ⟨<i>mp</i> <sub>1</sub>⟩ ⟨<i>mp</i> <sub>2</sub>⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~append/t</code> pattern matches a (possibly improper) list, breaking it
  into two sub-list segments to be matched against ⟨<i>mp</i> <sub>1</sub>⟩ and
  ⟨<i>mp</i> <sub>2</sub>⟩ sub-patterns.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;The number of pairs in the “spine”
  of the second segment is assumed to be equal to the number of “spine” pairs in the
  ⟨<i>datum</i> ⟩ argument. The pattern fails if the input list is
  too short to be broken in this way.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  This is a non-iterative pattern, providing
  a degree of efficiency where the length of the tail pattern is known at macroexpand time.
</p>

<p>
  <code>(<b>~etc</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~etc</code> pattern matches a proper list such that every one
  of its elements matches ⟨<i>mp</i> ⟩. If this sub-pattern
  contains pattern vars, they will be bound to lists of values obtained via
  individual element matches in the order of their appearance in the input
  list. This pattern can be compared to the postfix ellipsis (<code>...</code>)
  notation popularized by <code>syntax-rules</code>.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  If one or more sub-pattern
  variables are also used outside <code>~etc</code> in the same rule-level pattern,
  the non-linear “agreement” rule is applied to the final list values collected
  by <code>~etc</code> pattern on a successful match.
</p>

<p>
  <code>(<b>~etcse</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~etcse</code> pattern works similarly to the <code>~etc</code> pattern,
  but it never fails on proper lists (<em>sine errore</em> mode). If an element of
  the input list does not match the ⟨<i>mp</i> ⟩ subpattern, it is skipped.
</p>


<h3 id="vector-patterns">Vector patterns</h3>

<p>
A limited set of vector patterns is provided. Advanced matching of vectors
can be performed either by combining list patterns with <code>~list-&gt;vector</code>
converter pattern, or by using core patterns described further below.
</p>

<p>
  <code>(<b>~vector</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~vector</code> pattern matches a vector with as many elements
  as there are sub-patterns ⟨<i>mp</i> ⟩ … The elements
  should match the corresponding patterns.
</p>

<p>
  <code>(<b>~vector-append</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern (iterative, greedy)</i><br>
  The <code>~vector-append</code> pattern matches a vector, breaking it into
  sub-vector segments that can match the corresponding patterns
  ⟨<i>mp</i> ⟩ … <br>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  This is another example of an <i>iterative</i>
  pattern that may match the target vector in many different ways; the “solutions” are attempted starting
  with ones maximizing the length of the leftmost segment, then the segment after it, etc.
</p>

<p>
  <code>(<b>~vector-append/ng</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern (iterative, non-greedy)</i><br>
  The <code>~vector-append/ng</code> pattern is a “non-greedy” variant of the
  <code>~vector-append</code> pattern. The solutions are attempted starting with the ones maximizing
  the length of the rightmost segment, then the segment before it, etc.
</p>

<h3 id="string-patterns">String patterns</h3>

<p>
A limited set of string patterns is provided. Advanced matching of strings
can be performed either by combining list patterns with the <code>~list-&gt;string</code>
converter pattern, or by using core patterns described further below.
</p>

<p>
  <code>(<b>~string</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~string</code> pattern matches a string with as many characters
  as there are sub-patterns ⟨<i>mp</i> ⟩ … The characters
  should match the corresponding patterns.
</p>

<p>
  <code>(<b>~string-append</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern (iterative, greedy)</i><br>
  The <code>~string-append</code> pattern matches a string, breaking it into
  sub-string segments that can match the corresponding patterns
  ⟨<i>mp</i> ⟩ … <br>
  &nbsp;&nbsp;&nbsp;&nbsp;This is an iterative pattern; the “solutions” are attempted starting
  with ones maximizing the length of the leftmost segment, then the segment after it, etc.
</p>

<p>
  <code>(<b>~string-append/ng</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern (iterative, non-greedy)</i><br>
  The <code>~string-append/ng</code> pattern is a “non-greedy” variant of the
  <code>~string-append</code> pattern. The solutions are attempted starting with the ones maximizing
  the length of the rightmost segment, then the segment before it, etc.
</p>

<h3 id="conversion-patterns">Conversion patterns</h3>

<p>
These patterns extend the functionality of the matcher, allowing it to deal with
numbers and symbols as strings, strings and chars as numbers, etc. They are named
as the corresponding constructors, so they match the types of objects on the right-hand
side of <code>-&gt;</code>, e.g. <code>~list-&gt;vector</code> matches vectors, but
applies its sub-pattern to the result of converting it to the list. They should be read
as converters for the <i>patterns</i> : <code>~list-&gt;vector</code> makes
a vector pattern from a list pattern, and so on.
</p>

<p>
  <code>(<b>~vector-&gt;list</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~string-&gt;list</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~list-&gt;vector</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~list-&gt;string</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~string-&gt;symbol</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~symbol-&gt;string</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  Convert a pattern built to match objects of the type on the left side of <code>-&gt;</code>
  to the pattern able to match objects of the type on the right side of <code>-&gt;</code>,
  applying the “reverse” converter function internally. E.g. if ⟨<i>mp</i> ⟩
  can match lists of characters, <code>(<b>~list-&gt;string</b></code> ⟨<i>mp</i> ⟩<code>)</code>
  will be able to match strings containing the same characters.
</p>

<p>
  <code>(<b>~string-&gt;number</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~string-&gt;number</b></code> ⟨<i>mp</i> ⟩ ⟨<i>rx</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
    <code>(<b>~number-&gt;string</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~number-&gt;string</b></code> ⟨<i>mp</i> ⟩ ⟨<i>rx</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  These patterns convert between number and string patterns, accepting an optional
  ⟨<i>rx</i> ⟩ argument. This additional argument is an expression that is evaluated
  when the pattern is applied, and should produce a radix, suitable for Scheme
  <code>string-&gt;number</code> / <code>number-&gt;string</code> procedures.
</p>

<h3 id="predicate-patterns">Predicate patterns</h3>

<p>
The role of predicate patterns is to “guard” their optional sub-patterns, making sure
that the input object belongs to a certain Scheme type. Their set is limited, but new
ones can be easily defined, as explained in the section on derived patterns below.
</p>

<p>
  <code>(<b>~null?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~pair?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~list?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~boolean?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~number?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~integer?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~vector?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~string?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~symbol?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~char?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
These patterns match if the input object satisfies the like-named Scheme predicate, and
if there are sub-patterns, <em>all</em> sub-patterns match the same input object, as if
combined with the <code>~and</code> pattern combinator (see below).
</p>

<h3 id="logical-patterns">Logical patterns</h3>

<p>
These patterns apply their sub-patterns to the same input object, combining the
results of individual sub-pattern matches.
</p>

<p>
  <code>(<b>~and</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
This pattern matches if <em>all</em> its sub-patterns match the input object. If
sub-patterns contain pattern variables, all of them are bound on a successful match. If there
are no sub-patterns, the <code>(~and)</code> pattern matches any object.
</p>

<p>
  <code>(<b>~or</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern (iterative)</i><br>
This pattern matches if <em>any</em> of its sub-patterns matches the input object. The
sub-patterns are tried in the order they are written, and the process stops on
the first sub-pattern that matches successfully (but see the note below). If sub-patterns
contain pattern variables, all of them are bound on a match, but only the ones
belonging to the “successful” sub-pattern will have their variables bound to the
corresponding sub-values. The remaining variables are bound to <code>#f</code>.
If there are no sub-patterns, the <code>(~or)</code> pattern fails on every object.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  this pattern is iterative in the following
sense: if backtracking exhausts all possible match solutions for one sub-pattern, the next
one is tried, then the next one, etc.
</p>

<p>
  <code>(<b>~not</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
This pattern matches if its sub-pattern fails to match the input object. If
it contains pattern variables, none of them are bound on a successful match
(i.e. when the sub-pattern fails). It is an error for a pattern to refer to
the same pattern variable inside and outside of a <code>~not</code> pattern.
</p>

<h3 id="compatibility-patterns">Compatibility patterns</h3>

<p>
  These patterns provide functionality popularized by the “Wright-style” family of matchers.
</p>

<p>
  <code>(<b>~list*</b></code> ⟨<i>mp</i> ⟩ … ⟨<i>mp</i> <sub>t</sub>⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~list*</code> pattern matches a (possibly improper) list with at least as many elements
  as there are sub-patterns ⟨<i>mp</i> ⟩ … The elements
  should match the corresponding patterns; the remaining part of the list should match the
  last pattern, ⟨<i>mp</i> <sub>t</sub>⟩.
</p>

<p>
  <code>(<b>~list-no-order</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  This pattern matches a proper list with as many elements
  as there are sub-patterns ⟨<i>mp</i> ⟩ … It iterates through
  all possible permutations of the input list looking for one with elements that
  match the corresponding sub-patterns.
</p>

<p>
  <code>(<b>~list-no-order*</b></code> ⟨<i>mp</i> ⟩ … ⟨<i>mp</i> <sub>t</sub>⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  This pattern matches a (possibly improper) list with at least as many elements
  as there are sub-patterns ⟨<i>mp</i> ⟩ … The elements,
  in some permutation of the original order, should match the corresponding patterns;
  the remaining part of the list should match the
  last pattern, ⟨<i>mp</i> <sub>t</sub>⟩.
</p>

<p>
  <code>(<b>~=</b></code> ⟨<i>fn</i> ⟩
  ⟨<i>mp</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
In this pattern, ⟨<i>fn</i> ⟩ is not a pattern. The pattern
binds its input value to a fresh variable ⟨<i>iv</i> ⟩,
and then evaluates the <code>(</code>⟨<i>fn</i> ⟩
⟨<i>iv</i> ⟩<code>)</code> expression; its result is matched
against the ⟨<i>mp</i> ⟩ sub-pattern.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  ⟨<i>fn</i> ⟩ does not have
to name a function; it can be of any form. The combined expression is evaluated
as is so the matching process may be interrupted in case of errors.
</p>

<p>
  <code>(<b>~?</b></code> ⟨<i>fn</i> ⟩
  ⟨<i>mp</i> ⟩ …<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
In this pattern, ⟨<i>fn</i> ⟩ is not a pattern. The pattern binds its
input value to a fresh variable ⟨<i>iv</i> ⟩,
and evaluates the <code>(</code>⟨<i>fn</i> ⟩
⟨<i>iv</i> ⟩<code>)</code> expression. If the expression evaluates
to <code>#f</code>, the pattern fails. Otherwise, the input object is matched
against ⟨<i>mp</i> ⟩… sub-patterns, combined via
<code>~and</code> (i.e. all of them should match).<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  ⟨<i>fn</i> ⟩ does not have
to name a function; it can be of any form. The expression is evaluated
as is, so the matching process may be interrupted in case of errors.
</p>

<h3 id="core-patterns">Core patterns</h3>

<p>
These patterns may not be as compact, nor as convenient to use as the ones described above,
but they provide functionality needed to build derived patterns via <code>define-match-pattern</code>
(see below). In fact, all patterns described above except for <code>~etc</code>, basic and logical ones are implementable
in this way; some of the possible derivations are shown in the Appendix.
</p>

<p>
  <code>(<b>~prop</b></code> ⟨<i>fn</i> ⟩
  <code>=&gt;</code> ⟨<i>mp</i> ⟩ …<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~prop</b></code> ⟨<i>fn</i> ⟩
  <code>(</code>⟨<i>arg</i> ⟩ …<code>)</code>
  <code>=&gt;</code> ⟨<i>mp</i> ⟩ …<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
In this pattern, ⟨<i>fn</i> ⟩ and all ⟨<i>arg</i> ⟩s
are not patterns. The pattern binds its input value to a fresh variable ⟨<i>iv</i> ⟩,
and then evaluates the <code>(</code>⟨<i>fn</i> ⟩ ⟨<i>iv</i> ⟩
⟨<i>arg</i> ⟩…<code>)</code> expression; its results are matched against the
⟨<i>mp</i> ⟩ … sub-patterns.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  ⟨<i>fn</i> ⟩ does not have
to name a function; it can be of any form. The combined expression is evaluated
as is, so the matching process may be interrupted in case of errors.
</p>

<p>
  <code>(<b>~test</b></code> ⟨<i>fn</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~test</b></code> ⟨<i>fn</i> ⟩
  <code>(</code>⟨<i>arg</i> ⟩ …<code>))</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~test</b></code> ⟨<i>fn</i> ⟩
  <code>=&gt;</code> ⟨<i>mp</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
  <code>(<b>~test</b></code> ⟨<i>fn</i> ⟩
  <code>(</code>⟨<i>arg</i> ⟩ …<code>)</code>
  <code>=&gt;</code> ⟨<i>mp</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
In this pattern, ⟨<i>fn</i> ⟩ and all ⟨<i>arg</i> ⟩s
are not patterns. The pattern binds its input value to a fresh variable ⟨<i>iv</i> ⟩,
and evaluates the <code>(</code>⟨<i>fn</i> ⟩ ⟨<i>iv</i> ⟩
⟨<i>arg</i> ⟩…<code>)</code> expression. If the expression evaluates to <code>#f</code>,
the pattern fails. Otherwise, if ⟨<i>mp</i> ⟩
sub-pattern is present, it should also match the result; if it is absent, the match just
succeeds.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  ⟨<i>fn</i> ⟩ does not have
to name a function; it can be of any form. The expression is evaluated
as is, so the matching process may be interrupted in case of errors.
</p>

<p>
  <code>(<b>~iterate</b></code> ⟨<i>start</i> ⟩
  ⟨<i>head</i> ⟩ ⟨<i>tail</i> ⟩
  <code>(</code>⟨<i>var</i> ⟩…<code>)</code>
  ⟨<i>mp</i> ⟩<code>)</code> &nbsp;&nbsp;<i>match pattern</i><br>
  This pattern combinator builds a backtracking matcher
  that produces a stream of “solutions” to be matched against
  ⟨<i>mp</i> ⟩; ⟨<i>start</i> ⟩,
  ⟨<i>head</i> ⟩, ⟨<i>tail</i> ⟩,
  and all ⟨<i>var</i> ⟩s are not patterns. Internally,
  it uses an iterative loop with ⟨<i>var</i> ⟩…
  serving is a list of state variables (their names should be different,
  but otherwise unimportant due to hygiene). The rest of the non-pattern
  arguments are used to form internal expressions and can be either names
  of procedures or macros. They are used as follows:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;⟨<i>start</i> ⟩ is invoked
  with the original value and two continuation procedures:
  first one (<i>try</i> ) accepts 'seed' values for state variables
  if start succeeds, the second one (<i>fail</i> ) accepts no values
  and is called if start fails.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;⟨<i>head</i> ⟩ accepts current
  values of state variables and returns a single value to be matched against
  ⟨<i>mp</i> ⟩ pattern.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;⟨<i>tail</i> ⟩ accepts the
  same two continuations as ⟨<i>start</i> ⟩, followed by
  the current values of state variables. It should either apply its
  <i>try</i>  continuation to continue with new values of state vars,
  or apply its <i>fail</i>  one to signal that there are no more “solutions”.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  both <i>try</i>  and
  <i>fail</i>  should be applied in tail positions.
</p>

<!-- p>
  <code>(<b>~!</b></code> &langle;<i>mp</i>&thinsp;&rangle;<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br/>
This pattern, pronounced as “cut!”, should be familiar to Prolog programmers.
It provides a degree of control for iterative behavior of its sub-pattern,
&langle;<i>mp</i>&thinsp;&rangle;. It re-arranges the control in
such a way, that when the first “solution” for its sub-pattern is found,
it is taken as the only one, and the sub-pattern is never re-tried unless
the whole <code>~!</code> pattern is re-tried.
</p -->

<h3 id="pattern-language-construction-patterns">Pattern language construction patterns</h3>

<p>
This SRFI facilitates creation of entirely new pattern-matching forms
via derivation. Some of such derived forms may have special needs, met by
the pattern combinators below.
</p>

<p>
  <code>(<b>~if-id-member</b></code> ⟨<i>id</i> ⟩
  <code>(</code> ⟨<i>literal-id</i> ⟩ …<code>)</code>
  ⟨<i>mp</i> <sub>t</sub>⟩ ⟨<i>mp</i> <sub>f</sub>⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
This pattern selects one of the two sub-pattern arguments based on the first two
non-pattern arguments. The ⟨<i>id</i> ⟩ argument is a match
pattern identifier, but it is not used as a sub-pattern. The second argument is a list
of distinct match pattern identifiers; they are also not used as sub-patterns.
The <code>~if-id-member</code> checks if ⟨<i>id</i> ⟩ is
in the list of ⟨<i>literal-id</i> ⟩s, selecting the
first sub-pattern for matching if it is there, or the second sub-pattern if it's not.
The method of comparison is the same as the one used to compare input identifiers
with the list of literal identifiers in <code>syntax-rules</code>.
</p>

<p>
  <code>(<b>~replace-specials</b></code> ⟨<i>new ...</i> ⟩
  ⟨<i>new _</i> ⟩  ⟨<i>mp</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
This pattern matches ⟨<i>mp</i> ⟩ after replacing all ellipsis
(<code>...</code>) identifiers in it with ⟨<i>new ...</i> ⟩, and
all underscore (<code>_</code>) identifiers with ⟨<i>new _</i> ⟩.
This is useful if ⟨<i>mp</i> ⟩ incorporates patterns designed to
use regular ellipsis and/or underscore as part of its syntax. Replacing them allows
pattern rewriting rules (see <code>define-match-pattern</code> below) to employ these
identifiers in their special role, controlling the rewriting.
</p>

<h3 id="defining-new-patterns">Defining new patterns</h3>

<p>
New patterns can be defined using a pattern rewriting system, replicating the
functionality of <code>syntax-rules</code>, but using patterns instead of regular
Scheme expressions or definitions. It hides the details of the internal pattern
macroexpansion protocol, creating an illusion that patterns expand into
combinations of other patterns directly.
</p>

<p>
  <code>(<b>define-match-pattern</b></code> ⟨<i>name</i> ⟩
  <code>(</code>⟨<i>literal-id</i> ⟩ …<code>)</code>
  <code>(</code>⟨<i>imp</i> ⟩ ⟨<i>omp</i> ⟩<code>)</code> …
  <code>)</code>
  &nbsp;&nbsp;<i>syntax</i><br>
  This form expands into an equivalent of<br><br>
   <code>(define-syntax</code> ⟨<i>name</i> ⟩
   <code>(syntax-rules (</code>⟨<i>literal-id</i> ⟩ …<code>)</code>
    ⟨<i>rule</i> ⟩ …<code>))</code><br><br>
  where ⟨<i>name</i> ⟩ is a new match pattern name, and each
  ⟨<i>rule</i> ⟩ is a <code>syntax-rules</code> transformation rule,
  created from a pair of an input pattern ⟨<i>imp</i> ⟩
  and the corresponding output pattern ⟨<i>omp</i> ⟩. Please see
  the description of <code>syntax-rules</code> for the details.
</p>

<p>
To show how it works in practice, here's a definition of a <code>~qq</code> pattern,
equivalent to the built-in <code>quasiquote</code> pattern; it implements the T[ ] transcription
function. More examples are available
in the Examples section and in the Appendix below. </p>

<pre><code>(<b>define-match-pattern</b> ~qq (unquote unquote-splicing)
  [(_ ,p)          p]
  [(_ (,@lp))      lp]
  [(_ (,@lp . dp)) (~append lp (~qq dp))]
  [(_ (ap . dp))   (~cons (~qq ap) (~qq dp))]
  [(_ #(p ...))    (~vector (~qq p) ...)]
  [(_ a)           (quote a)])

(<b>match</b> '(1 (2 . 3) #(4))
  [(~qq (,x (,y . ,z) #(,t)))
       `(,x (,y . ,z) #(,t))])
⟹ (1 (2 . 3) #(4))
</code></pre>

<h3 id="elements-of-templating">Elements of templating</h3>

<p>
Although the bulk of this proposal is dedicated to patterns, there are a few things
that can be done to simplify the templating too. There is some symmetry between the
pattern language and the regular Scheme expressions, which in many cases allows one
to re-create the input object by constructing it back in the same way it was
taken apart, e.g.:
</p>

<pre><code>(<b>match</b> '(1 (2 . 3) #(4))
  [(~list x (~cons y z) (~vector t))
    (list x  (cons y z)  (vector t))])
⟹ (1 (2 . 3) #(4))

(<b>match</b> '(1 (2 . 3) #(4))
  [`(,x (,y . ,z) #(,t))
   `(,x (,y . ,z) #(,t))])
⟹ (1 (2 . 3) #(4))
</code></pre>

<p>
Things get more complicated when one has to deal with “ellipsis” expressions. To
re-construct them, one has to use <code>map</code> with a <code>lambda</code> expression
containing the element construction code. To simplify this process, two extra syntax forms are provided.
</p>

<p>
  <code>(<b>value</b></code> ⟨<i>expression</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>procedure or syntax</i><br>
This form just evaluates ⟨<i>expression</i> ⟩ and returns its
value, complementing the <code>~value</code> pattern. It is also the only form other
than <code>quote</code> recognized by name by the <code>etc</code> syntax form:
</p>

<p>
  <code>(<b>etc</b></code> ⟨<i>constructor</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>syntax</i><br>
This form may help in shortening the construction code needed to combine lists
produced by a successful <code>~etc</code> pattern. The ⟨<i>constructor</i> ⟩
argument is a limited form of expression: it is either an ⟨<i>atomic datum</i> ⟩,
an identifier, a quoted S-expression (a two element list starting with <code>quote</code>),
a <code>value</code> expression (see above), or an application or macro use in a form of a list that
starts with an identifier, followed by zero or more ⟨<i>constructor</i> ⟩s. <br>
&nbsp;&nbsp;&nbsp;&nbsp;The <code>etc</code> form is expanded as follows: first, it is
scanned for variables.  It collects all identifiers outside of <code>quote</code> and <code>value</code>
forms that are not used as head identifiers of an application or macro use. Then, a <code>map</code> application
is built, with a <code>lambda</code> form with the collected variables as formal parameters
and the ⟨<i>constructor</i> ⟩ as its body, followed by the same
variables as the lists for <code>map</code> to process. The variables do not have to be
taken from patterns, they can come from any place in the current context; all decisions on
which variables are unrolled and which are replicated are explicit.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Uses of the <code>etc</code> form can be nested:
</p>

<pre><code>(<b>match</b> '((0) (1 2) (3 4 5) (6 7 8 9))
  [(~etc (~cons x (~etc y*)))
    (etc  (cons x  (etc y*)))])
⟹ ((0) (1 2) (3 4 5) (6 7 8 9))

(<b>match</b> '((0) (1 2) (3 4 5) (6 7 8 9))
  [(~etc (~cons x (~etc y*)))
   (cons (etc x) (etc y*))])
⟹ ((0 1 3 6) () (2) (4 5) (7 8 9))

</code></pre>

<h2 id="sublibs">Sublibraries and optional features</h2>

<p>
In addition to the above syntax forms exported by the main <code>(srfi 257)</code> library,
there are three utility libraries, which could be defined portably in terms of the core but
are provided as convenience extensions. The <code>box</code> and <code>rx</code> sublibraries
are defined conditionally, based on support for <a href="https://srfi.schemers.org/srfi-111/">SRFI 111</a> and
<a href="https://srfi.schemers.org/srfi-115/">SRFI 115</a>/<a href="https://srfi.schemers.org/srfi-264/">SRFI 264</a> respectively.
</p>

<h3 id="sublibs-misc">The ‘misc’ sublibrary</h3>

<p>
The <code>(srfi 257 misc)</code> sublibrary exports miscellaneous forms defined in the Examples section.
</p>

<p>
  <code>(<b>~etc+</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~etc+</code> pattern matches a proper nonempty list such that every one
  of its elements matches ⟨<i>mp</i> ⟩. It is equivalent to the <code>~etc</code> pattern,
  constrained to fail on empty lists.
</p>

<p>
  <code>(<b>~etc=</b></code> ⟨<i>lp</i> ⟩ ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~etc=</code> pattern matches a proper list such that its length matches the
  ⟨<i>lp</i> ⟩ pattern, and every one of its elements matches the ⟨<i>mp</i> ⟩ pattern.
  It is equivalent to the <code>~etc</code> pattern, constrained by list length.
</p>

<p>
  <code>(<b>~etc**</b></code> ⟨<i>k</i> ⟩ ⟨<i>j</i> ⟩ ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~etc**</code> pattern matches a proper list such that its length lies in a range,
  defined by the ⟨<i>k</i> ⟩ and ⟨<i>j</i> ⟩ expressions (inclusive), and every one of its elements matches the ⟨<i>mp</i> ⟩ pattern.
  It is equivalent to the <code>~etc</code> pattern, constrained by list length.<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>Note:</i>  The first two arguments are expressions, evaluated
  each time the pattern is considered for a match.<br>
</p>

<p>
  <code>(<b>cm-match</b></code> ⟨<i>expression</i> ⟩ ⟨<i>cm-rule</i> ⟩<code> &hellip;)</code>
    &nbsp;&nbsp;<i>syntax</i><br>
  The <code>cm-match</code> form implements a variant of Dybvig-Friedman-Hilsdale
  matcher, as specified in <a href="https://srfi.schemers.org/srfi-241/">SRFI 241</a>. Compared to the original, <code>cm-match</code>
  is more compact, but it does not implement D-F-H matcher's enhanced right-hand-side <code>quasiquote</code>.
</p>

<p>
  <code>(<b>sr-match</b></code> ⟨<i>expression</i> ⟩ ⟨<i>literals</i> ⟩ ⟨<i>sr-rule</i> ⟩<code> &hellip;)</code>
    &nbsp;&nbsp;<i>syntax</i><br>
  The <code>sr-match</code> form implements a matcher that uses <code>syntax-rules</code>
  -like pattern conventions: a symbolic pattern is treated as ⟨<i>match pattern name</i> ⟩
  unless it is contained in the list of ⟨<i>literals</i> ⟩. Each ⟨<i>sr-rule</i> ⟩
  is similar to the regular ⟨<i>match rule</i> ⟩ as described in the main specification,
  with the following change: instead of ⟨<i>match pattern</i> ⟩,
  ⟨<i>sr-rule</i> ⟩ starts with an ⟨<i>sr-pattern</i> ⟩, which is either an
  empty list (matches itself), an ⟨<i>atomic datum</i> ⟩ (matches any
  <code>equal?</code> object), an ⟨<i>underscore</i> ⟩ (matches any object),
  a ⟨<i>match pattern name</i> ⟩ (matches and binds any object), a ⟨<i>literal</i> ⟩
  (matches itself), or a pair/vector of ⟨<i>sr-pattern</i> ⟩s, matched recursively
  with a similarly-structured objects. If element of a list or vector is immediately followed
  by an ⟨<i>ellipsis</i> ⟩, this element is matched as if implicitly wrapped in <code>~etc</code>
  pattern; as <code>syntax-rules</code>, <code>sr-match</code> does not support multiple
  ellipses on the same level.
</p>

<h3 id="sublibs-box">The ‘box’ sublibrary</h3>

<p>
Systems that support <a href="https://srfi.schemers.org/srfi-111/">SRFI 111</a> should provide <code>(srfi 257 box)</code>
sublibrary exporting the following match patterns.
</p>

<p>
  <code>(<b>~box?</b></code> ⟨<i>mp</i> ⟩ …<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
This pattern matches if the input object satisfies the <code>box?</code> predicate, and
if there are sub-patterns, <em>all</em> sub-patterns match the same input object, as if
combined with the <code>~and</code> pattern combinator.
</p>

<p>
  <code>(<b>~box</b></code> ⟨<i>mp</i> ⟩<code>)</code>
    &nbsp;&nbsp;<i>match pattern</i><br>
  The <code>~box</code> pattern matches a box input object; its contents
  should match the ⟨<i>mp</i> ⟩ subpattern.
</p>

<h3 id="sublibs-rx">The ‘rx’ sublibrary</h3>

<p>
Systems that support <a href="https://srfi.schemers.org/srfi-115/">SRFI 115</a> (Scheme Regular Expressions) and
<a href="https://srfi.schemers.org/srfi-264/">SRFI 264</a> (String syntax for Scheme Regular Expressions)
should provide <code>(srfi 257 rx)</code> sublibrary exporting the following syntax and
match patterns. All match patterns below fail on non-string input objects.
</p>

<p>
<code>(<b>rx</b></code> ⟨<i>sre</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>syntax</i><br>
The <code>rx</code> regexp constructor is re-exported verbatim from SRFI 115, so
there is no need to import it separately for simple uses.
</p>

<p>
The ⟨<i>re</i> ⟩ argument in all patterns below is an expression that should evaluate
to either a regexp (e.g. be a <code>rx</code> macro use), or to a string, which is expected to
be in <a href="https://srfi.schemers.org/srfi-264/">SRFI 264</a> SSRE regexp notation. All other arguments are match
patterns. Procedures mentioned in the descriptions are from <a href="https://srfi.schemers.org/srfi-115/">SRFI 115</a>.
</p>

<p>
<code>(<b>~/</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
The <code>~/</code> pattern matches a string input object; its full contents
should match the ⟨<i>re</i> ⟩ regexp, as specified by the <code>regexp-matches</code> procedure.
The ⟨<i>mp</i> ⟩&hellip; subpatterns, as many as present, should match the corresponding regexp submatch
strings: first ⟨<i>mp</i> ⟩ should match submatch 0 (the whole input string), the second
⟨<i>mp</i> ⟩ should match the first regexp capture group, and so on. Note: ⟨<i>mp</i> ⟩s match
the initial elements of the list returned by the <code>regexp-match->list</code> procedure;
the pattern will fail if there are more ⟨<i>mp</i> ⟩s than strings returned by the procedure.
</p>

<pre><code>(<b>match</b> "foo:123" [(~/ "([a-z]*):([0-9]*)" s aa dd) (list s aa dd)] [_ #f])
⟹ ("foo:123" "foo" "123")
</code></pre>

<p>
<code>(<b>~/sub</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
This pattern is similar to the <code>~/</code> pattern above, but it allows the ⟨<i>re</i> ⟩ regexp to match
a substring of the input string, as specified by the <code>regexp-search</code> procedure. The
first matching substring and its corresponding capture groups strings are matched against
the ⟨<i>mp</i> ⟩s.
</p>

<p>
<code>(<b>~/any</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>match pattern (iterative)</i><br>
Similar to the <code>~/sub</code> pattern above, but is able to look beyond the first match, trying
all matches in order until if finds the substring and its corresponding capture groups strings
that match the ⟨<i>mp</i> ⟩s. Fails if there are no successful matches.
</p>

<p>
<code>(<b>~/all</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
<code>(<b>~/all+</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
<code>(<b>~/etc</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
<code>(<b>~/etc+</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
<code>(<b>~/etcse</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩&hellip;<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
These patterns extract all substrings of the input string matched by the ⟨<i>re</i> ⟩ regexp,
as specified by the <code>regexp-fold</code> procedure. The ‘all’ match patterns do not
fail even if ⟨<i>re</i> ⟩ matches no substrings; the ‘+’ ones fail if no substrings are found.
In the first pair of patterns, the ⟨<i>mp</i> ⟩&hellip; subpatterns are matched against the parallel
lists of the submatch/capture strings as described above; their original order in the input string
is preserved.
The ‘etc’/‘etc+’ patterns wrap their ⟨<i>mp</i> ⟩&hellip; subpatterns in an implicit <code>~etc</code>
pattern, so they are matched against individual substrings before being aggregated into lists. This
is useful if additional constraints need to be set on individual substrings to filter the resulting lists.
The ‘etcse’ pattern wraps its ⟨<i>mp</i> ⟩&hellip; subpatterns in an implicit <code>~etcse</code>
pattern, skipping matches that fail the subpattern constraints. Thus, the <code>~/etcse</code> pattern
never fails on any input string.
</p>

<p>
<code>(<b>~/extracted</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
<code>(<b>~/split</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
<code>(<b>~/partitioned</b></code> ⟨<i>re</i> ⟩ ⟨<i>mp</i> ⟩<code>)</code>
  &nbsp;&nbsp;<i>match pattern</i><br>
These patterns extract all substrings of the input string matched by the ⟨<i>re</i> ⟩ regexp,
and/or in-between substrings, as specified by the <code>regexp-extract</code>, <code>regexp-split</code>, and
<code>regexp-partition</code> procedures respectively. The ⟨<i>mp</i> ⟩ subpattern is
matched against the list of the corresponding substrings; their original order in the input string is preserved.
</p>


<h3 id="optional-features">Optional features</h3>

<p>
  Systems that support boxes and <code>#&amp;</code> read syntax for box literals (e.g. Chez Scheme)
  may support box literal patterns as part of ⟨<i>match pattern</i> ⟩, as well as both
  <code>cm-match</code> and <code>sr-match</code> patterns.
</p>

<br/>


<h2 id="appendix">Appendix</h2>

<h3 id="derived-pattern-types">Derived pattern types</h3>

<p>
This appendix gives possible definitions for some derived pattern types in terms of
the basic, logical, and core pattern types.
</p>

<pre><code>(<b>define-match-pattern</b> ~value ()
  [(_ e)
   (~test equal? (e))])

(<b>define-match-pattern</b> ~cons ()
  [(_ ap dp)
   (~and (~test pair?) (~prop car =&gt; ap) (~prop cdr =&gt; dp))])

(<b>define-match-pattern</b> ~list ()
  [(~list) '()]
  [(~list p . p*) (~cons p (~list . p*))])

(<b>define-match-pattern</b> ~list* ()
  [(~list* p) p]
  [(~list* p . p*) (~cons p (~list* . p*))])

(<b>define-syntax</b> match:cno-start
  (<b>syntax-rules</b> ()
    [(_ xv try f)
     (<b>if</b> (pair? xv) (try '() xv) (f))]))

(<b>define-syntax</b> match:cno-head
  (<b>syntax-rules</b> ()
    [(_ h t)
     (cons (car t) (append h (cdr t)))]))

(<b>define-syntax</b> match:cno-tail
  (<b>syntax-rules</b> ()
    [(_ try f h t)
     (<b>if</b> (pair? (cdr t)) (try (cons (car t) h) (cdr t)) (f))]))

(<b>define-match-pattern</b> ~cons-no-order ()
  [(~cons-no-order pe pr)
   (~iterate match:cno-start match:cno-head match:cno-tail (h t)
     (~cons pe pr))])

(<b>define-match-pattern</b> ~list-no-order ()
  [(~list-no-order) '()]
  [(~list-no-order p) (~list p)]
  [(~list-no-order p . p*)
   (~cons-no-order p (~list-no-order . p*))])

(<b>define-match-pattern</b> ~list-no-order* ()
  [(~list-no-order* p) p]
  [(~list-no-order* p . p*)
   (~cons-no-order p (~list-no-order* . p*))])

(<b>define-match-pattern</b> ~vector? ()
  [(_ p ...)
   (~and (~test vector?)  p ...)])

(<b>define-match-pattern</b> ~vector-&gt;list ()
  [(_ p)
   (~and (~test list?) (~prop list-&gt;vector =&gt; p))])

(<b>define-match-pattern</b> ~vector ()
  [(_ p ...)
   (~and (~test vector?) (~prop vector-&gt;list =&gt; (~list p ...)))])

(<b>define-match-pattern</b> ~number-&gt;string ()
  [(_ p)
   (~and (~test string?) (~prop string-&gt;number =&gt; p))]
  [(_ p rx)
   (~and (~test string?) (~prop string-&gt;number (rx) =&gt; p))])

(<b>define-match-pattern</b> ~= ()
  [(~= f p) (~prop f =&gt; p)])

(<b>define-match-pattern</b> ~? ()
  [(~? f p ...) (~and (~test f) p ...)])
</code></pre>


<h2 id="implementation">Implementation</h2>

<p>
Sample <code>syntax-rules</code>-based implementation is available.
It runs on many R6RS and R7RS and some R5RS Schemes.
</p>

<a href="xm11.scm">Source for the sample implementation.</a>

<p>
  The SRFI-257 repository also contains R7RS libraries and a SRFI-64-based test suite.
</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>
This proposal is both based on and inspired by the work of the following people:
Andrew K. Wright, Robert Cartwright, Alex Shinn, R. Kent Dybvig, Dan Friedman, Erik Hilsdale,
Chris Hanson, Gerald Jay Sussman, Marc Nieper-Wißkirchen, Dimitris Vyzovitis, Felix Thibault,
and Panicz Maciej Godek.
I am grateful to Andrew Pochinsky, Daphne Preston-Kendal, and John Cowan for their feedback.
Special thanks to Al* Petrofsky and Oleg Kiselyov for lessons in advanced macrology.
</p>

<h2 id="copyright">Copyright</h2>
<p>© 2024 Sergei Egorov</p>

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the “Software”), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.</p>
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
